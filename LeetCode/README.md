# 题解

- [链表专题](##链表专题)

- [树专题](##树专题)

## 链表专题

### 2.两数相加

```
给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。

如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。

您可以假设除了数字 0 之外，这两个数都不会以 0 开头。

示例：
输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)
输出：7 -> 0 -> 8
原因：342 + 465 = 807
```

[题解：](https://github.com/DangoSky/algorithm/blob/master/LeetCode/2.%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0.js)

1. 直接遍历链表，对两个节点的值进行相加。注意两个链表长度可能不一，需要判断当前的链表节点存在。


### 19.删除链表的倒数第N个节点

```
给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。

示例：

给定一个链表: 1->2->3->4->5, 和 n = 2.

当删除了倒数第二个节点后，链表变为 1->2->3->5.
```

[题解：](https://github.com/DangoSky/algorithm/blob/master/LeetCode/19.%20删除链表的倒数第N个节点.js)

1. 翻转一次链表，遍历到 n 的位置删除节点后再翻转回来。注意需要对第一个节点做特殊处理，如果删除的是第一个节点，则直接返回 `head.next` 就可以了。

2. 先遍历一次链表计算出链表长度，再遍历一次链表，根据 `curIndex + 1 === length - n` 的条件判断下一个节点是否是要删除的节点（curIndex从0开始）。同样需要对第一个节点做特殊处理。

3. 先后指针。快指针先走 n-1 步后慢指针再开始从头节点开始走。当快指针走到最后一个结点的时候，慢指针就走到了倒数第n个结点。使用一个 `pre = null` 来保存上一个节点，到达倒数第n个节点后使 `pre.next = slow.next` 再返回 head 即可。如果 `pre === null` 即要删除的是第一个节点，则直接返回 `slow.next`。

证明：

- 假设总共有N个结点，则倒数第n个结点就是正数第 N-n+1 个结点。
- 从头结点正向走到第 N-n+1 个结点需要走 N-n 步，而从头节点到链表最后一个结点需要走 N-1 步，所以还剩 n+1 步。
- 即让快指针先走 n+1 步后再让慢指针同时走直到快指针走到链表尾即可。


### 21.合并两个有序链表

```
将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

示例：
输入：1->2->4, 1->3->4
输出：1->1->2->3->4->4
```

[题解：](https://github.com/DangoSky/algorithm/blob/master/LeetCode/21.%20合并两个有序链表.js)

1. 建立一个新链表，遍历两个链表边比较节点值的大小边增加到新链表上。注意两个链表可能不等长，需要判断当前两个链表的节点是否存在。

2. 递归：可以看成是由多个相同的合并操作组合成的，每个合并过程都包括比较并取节点的值作为新节点的值，继续比较剩下的两个链表并放回其结果作为当前新节点的 next 指向。


### 23.合并K个排序链表

```
合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。

示例:
输入:
[
  1->4->5,
  1->3->4,
  2->6
]
输出: 1->1->2->3->4->4->5->6
```

[题解：](https://github.com/DangoSky/algorithm/blob/master/LeetCode/23.%20%E5%90%88%E5%B9%B6K%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8.js)

1. 同上题，只要加一个 for 循环 k，两两合并最后成一个链表即可。但貌似更优解是使用优先队列。


### 24.两两交换链表中的节点

```
给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。

你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

示例:
给定 1->2->3->4, 你应该返回 2->1->4->3.
```

[题解：](https://github.com/DangoSky/algorithm/blob/master/LeetCode/24.%20%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.js)

1. 递归：维护四个节点，取链表的第一个节点作为 first，第二个节点作为 second，第三个节点作为 three。只要使 `second.next = first`, 并递归操作 three，将其返回值赋值给`first.next`，每次递归都返回 second。


### 61.旋转链表

```
给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。

示例 1:
输入: 1->2->3->4->5->NULL, k = 2
输出: 4->5->1->2->3->NULL

解释:
向右旋转 1 步: 5->1->2->3->4->NULL
向右旋转 2 步: 4->5->1->2->3->NULL
```

[题解：](https://github.com/DangoSky/algorithm/blob/master/LeetCode/61.%20%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8.js)

1. 使用数组存储各个节点的值，再以此生成链表。注意为了避免 k 太大时循环太多次，使用 `k = k % arr.length` 优化，每次移动相当于将数组的末元素放到首位置上，`arr.unshift(arr.pop())`。

2. 相当于倒数第k个节点（正数第 len-k+1 个节点）变成了头节点，第 len-k 个节点变成了尾节点。所以移动到第len-k个节点，将其下一个节点缓存为新头节点，并将当前节点节点的 next 指向 null。再遍历到尾节点将其 next 修改为 head 即可。


### 82.删除排序链表中的重复元素 II

```
给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。

示例 1:
输入: 1->2->3->3->4->4->5
输出: 1->2->5
```

[题解：](https://github.com/DangoSky/algorithm/blob/master/LeetCode/82.%20%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%20II.js)

1. 使用两个变量 pre（初始化为null）和 end（初始化为 cur.next）记录重复节点的前一个节点和最后一个节点。循环链表，遇到有重复值的节点，就嵌套一次循环直至重复结束。如果 `pre === null`（首节点就重复了），则直接 `head = end.next`，否则 `pre.next = end.next`，以此截断调重复的节点。

2. 递归。若当前节点和下一个节点值不重复，则递归其 next 指针并将返回值作为当前节点的 next。若值重复了，则循环直至不重复，将不重复的节点进行递归并返回其返回值（作为上一次递归节点的 next）。


### 83.删除排序链表中的重复元素

``` 
给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。

示例 1:
输入: 1->1->2
输出: 1->2
```

[题解：](https://github.com/DangoSky/algorithm/blob/master/LeetCode/83.%20%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0.js)

1. 循环链表，遇到重复的就把当前节点的 next 修改为 next.next。

2. 递归。和上一题的区别在于，本题先递归求解当前节点的 next，这样就可以使得重复元素也出现一次。之后再判断当前节点和下一个节点是否值重复，重复的话则循环直至不重复再返回。

3. 使用一个数组记录每个节点值出现的次数（边循环边记录），判断当前节点的下一个节点值对应的数组值是否大于1，是则将 next 修改为 next.next。



### 86.分隔链表

```
给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。

你应当保留两个分区中每个节点的初始相对位置。

示例:
输入: head = 1->4->3->2->5->2, x = 3
输出: 1->2->2->4->3->5
```

[题解：](https://github.com/DangoSky/algorithm/blob/master/LeetCode/86.%20%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8.js)

1. 双指针，一个链表收集小于x的，一个链表收集大于等于x的，最后把后者连接到前者上。

2. 先把结点值缓存到两个数组，然后根据小的数组链接链表，再继续连接大的数组。


### 92.反转链表 II

```
反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。

说明:
1 ≤ m ≤ n ≤ 链表长度。

示例:
输入: 1->2->3->4->5->NULL, m = 2, n = 4
输出: 1->4->3->2->5->NULL
```

[题解：](https://github.com/DangoSky/algorithm/blob/master/LeetCode/92.%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%20II.js)

1. 将pre从m不断推移到n，把它连接到next后面并修改它的next指向，再将next连接到before后面。循环这个过程即可。例如 1->2->3->4->5->NULL,m=2,n=4。将pre(2)放到next(3)后面，就成了 3->2，改变pre(2)的next指向就成了3-2->4->5->NULL。再把next(3)链接到before(1)后面，1->3-2->4->5->NULL，以此类推。

- before为开始翻转的前一个结点
- pre为要开始翻转的结点
- next为pre的下一个结点

2. 遍历链表，使用数组暂存 m-n 节点的值（将节点值插入到数组头部）。再遍历一边，根据数组修改 m-n 的节点值。可以使用同一个函数进行两次遍历，再传一个参数表示是获取 or 修改节点值就可以。


### 109.有序链表转换二叉搜索树

```
给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。

本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。

示例:
给定的有序链表： [-10, -3, 0, 5, 9],

一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：

      0
     / \
   -3   9
   /   /
 -10  5
```

[题解：](https://github.com/DangoSky/algorithm/blob/master/LeetCode/109.%20%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.js)

1. 通过二叉搜索树的性质，可得链表的中间节点就是二叉树的根节点。使用快慢指针，慢指针每次移动一个节点，快指针每次移动两个节点，当快节点达到末尾时慢指针就到中间节点。对于一个偶数长度的链表，中间两个元素都可用来作二叉搜索树的根。找到中加节点后，把链表从中间断开成左右两部分（即树的左右子树），以此递归即可。需要使用一个变量来保存中间节点的前一个节点，将其 next 指向 null 就是左子树了。


### 138.复制带随机指针的链表

```
给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。要求返回这个链表的深拷贝。 

示例：
输入：
{"$id":"1","next":{"$id":"2","next":null,"random":{"$ref":"2"},"val":2},"random":{"$ref":"2"},"val":1}

解释：
节点 1 的值是 1，它的下一个指针和随机指针都指向节点 2 。
节点 2 的值是 2，它的下一个指针指向 null，随机指针指向它自己。
 
提示：
你必须返回给定头的拷贝作为对克隆列表的引用。
```

[题解：](https://github.com/DangoSky/algorithm/blob/master/LeetCode/138.%20%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8.js#L38)

1. 先循环一遍链表，使用 map 缓存链表的各个结点，以节点为键，以一个新节点为值。再循环一遍链表，根据当前节点的 next 从 map 中取出对应的新节点，重新给节点的 next 赋值。但这方法是 O(n)的空间复杂度，O(n)的时间复杂度。

2. 使用三次while循环。O(1)的空间复杂度，O(n)的时间复杂度。《剑指offer》第187页。
  - 第一次在原链表上增加复制的结点，如: 1->1`->2->2`->3->3`->4->4。
  - 第二次循环给复制的结点的random赋值，可以直接定位到原结点.random.next，即为要赋值结点的random。
  - 第三次循环截取出复制的链表，如 1`->2`->3`->4`，即为所求。


### 141.环形链表

```
给定一个链表，判断链表中是否有环。

为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。（示意图看原题）

示例 1：
输入：head = [3,2,0,-4], pos = 1
输出：true

解释：链表中有一个环，其尾部连接到第二个节点。
```

[题解：](https://github.com/DangoSky/algorithm/blob/master/LeetCode/141.%20%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8.js)

1. 快慢指针。慢指针每次走一个节点，快指针每次走两个节点。如果快指针和慢指针在中途相遇则说明有环。

2. 遍历链表，使用 map 存储每一个节点。如果当前节点在 map 中已经存在则有环，不存在的话则存进 map 中。

### 142.环形链表 II

```
给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。

为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。

说明：不允许修改给定的链表。

示例 1：
输入：head = [3,2,0,-4], pos = 1
输出：tail connects to node index 1

解释：链表中有一个环，其尾部连接到第二个节点。
```

[题解：](https://github.com/DangoSky/algorithm/blob/master/LeetCode/142.%20%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%20II.js)

1. 快慢指针。先使用快慢指针找出是否有环。有环的话，假设链表起点到入环起点的距离是 a，入环起点到快慢指针交点的距离是 b。因为快指针走过的距离一直都是慢指针的两倍，所以整个环的长度减去 b = a（即交点再到入环起点的距离是 a）。所以只要再让一个指针从链表起点和原先的慢指针同步走，两者相等时就是入环起点（因为两者走的距离都是 a）。

2. 先遍历一遍，使用 map 存储每个节点的值，如果当前节点已经在 map 中出现（即环的起点），则给该节点设一个标记值。之后在循环一次链表，找到该标记值返回当前节点即可。

### 143. 重排链表

```
给定一个单链表 L：L0→L1→…→Ln-1→Ln ，
将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…

你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

示例 1:
给定链表 1->2->3->4, 重新排列为 1->4->2->3.
```

[题解：](https://github.com/DangoSky/algorithm/blob/master/LeetCode/143.%20%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8.js)

1. 双向链表。先循环一遍链表，维护一个 pre 使链表成为双向链表（pre初始为 null，最终为链表的最后一个节点）。之后再循环链表，通过 pre 往回得到前一个节点，插在链表当中。需要注意的是循环的次数是链表长度的一半，且最后一次循环时需要把链表尾部指向null，把剩下的节点裁剪掉。

2. 使用数组缓存。先循环一遍链表存下每个节点。之后再根据数组将相应的节点插入链表中。

3. 先深拷贝一次链表（递归拷贝），再翻转该拷贝的链表。把翻转后的链表节点插入原链表即可。

### 147. 对链表进行插入排序

```
对链表进行插入排序。插入排序的动画演示如上。从第一个元素开始，该链表可以被认为已经部分排序（用黑色表示）。每次迭代时，从输入数据中移除一个元素（用红色表示），并原地将其插入到已排好序的链表中。

插入排序算法：
插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。
每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。
重复直到所有输入数据插入完为止。
 
示例 1：
输入: 4->2->1->3
输出: 1->2->3->4
```

[题解：](https://github.com/DangoSky/algorithm/blob/master/LeetCode/147.%20对链表进行插入排序.js)

1. 相当于选择排序。将当前节点和已好排序的链表中的每一个节点比较大小并插入。需注意的是刚开始遍历时已排好序的链表为空，以及若已排序链表的第一个节点值大于当前节点，这两种情况下是将当前节点插入到已排序链表的首部。


### 148. 排序链表

```
在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。

示例 1:
输入: 4->2->1->3
输出: 1->2->3->4
```

[题解：](https://github.com/DangoSky/algorithm/blob/master/LeetCode/148.%20%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8.js)

1. 同数组的选择排序。

2. 先使用数组存储链表中的节点值，对数组进行 sort 排序。再遍历链表给节点值重新赋值。

### 160. 相交链表

```
编写一个程序，找到两个单链表相交的起始节点。

输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出：Reference of the node with value = 8

输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。

注意：
如果两个链表没有交点，返回 null.
在返回结果后，两个链表仍须保持原有的结构。
可假定整个链表结构中没有循环。
程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。
```

[题解：](https://github.com/DangoSky/algorithm/blob/master/LeetCode/160.%20%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8.js)

1. 先获取两个链表的长度，让较长的链表先移动直至剩下的链表长度和另一个链表长度相等。再同时遍历两个链表，判断当前的节点是否相等，是的话则是交点。


### 203. 移除链表元素

```
删除链表中等于给定值 val 的所有节点。

示例:
输入: 1->2->6->3->4->5->6, val = 6
输出: 1->2->3->4->5
```

[题解：](https://github.com/DangoSky/algorithm/blob/master/LeetCode/203.%20%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0.js)

1. 直接遍历链表。但需要注意对头节点做特殊处理，对于头节点不是改变 cur.next, 而是直接修改 cur 和 head。

2. 递归。


### 206. 反转链表

```
反转一个单链表。

示例:
输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL
```

[题解：](https://github.com/DangoSky/algorithm/blob/master/LeetCode/206.%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.js)

1. 从第一个节点开始遍历，维护一个 pre 变量（初始化为 null）即可。

2. 递归。将下一个节点的 next 修改为 当前节点 head，head 的 next 修改为 null。

3. 使用数组缓存每个节点值，从数组尾部开始给每一个节点赋值。


### 234. 回文链表

```
请判断一个链表是否为回文链表。

示例 1:
输入: 1->2
输出: false

示例 2:
输入: 1->2->2->1
输出: true
```

[题解：](https://github.com/DangoSky/algorithm/blob/master/LeetCode/234.%20%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8.js)

1. 数组缓存每个节点。将数组转化为字符串，和翻转后的数组字符串化比较。

2. 双向链表。先给链表的每一个节点增加一个 pre 属性。同时从头到尾和从尾到头比较当前节点值是否相等。

3. 先深拷贝链表，再翻转链表，之后遍历两个链表，比较两者的当前节点值。


### 237. 删除链表中的节点

```
请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。

现有一个链表 -- head = [4,5,1,9]，它可以表示为:

示例 1:
输入: head = [4,5,1,9], node = 5
输出: [4,1,9]
解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.
```

[题解：](https://github.com/DangoSky/algorithm/blob/master/LeetCode/237.%20%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.js)

1. 直接修改待修改节点 的 val 和 next 就可以了。


### 328. 奇偶链表

```
给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。

请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。

示例 1:
输入: 1->2->3->4->5->NULL
输出: 1->3->5->2->4->NULL
```

[题解：](https://github.com/DangoSky/algorithm/blob/master/LeetCode/328.%20%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8.js)

1. 维护奇偶两条链表，遍历原先的链表将奇偶节点各自增加到相应的链表上，最后将偶链表拼接在奇链表上即可。

2. 先将链表的值存到数组中。再遍历链表修改当前节点的值。


### 445. 两数相加 II

```
给定两个非空链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储单个数字。将这两数相加会返回一个新的链表。你可以假设除了数字 0 之外，这两个数字都不会以零开头。

进阶:
如果输入链表不能修改该如何处理？换句话说，你不能对列表中的节点进行翻转。

示例:
输入: (7 -> 2 -> 4 -> 3) + (5 -> 6 -> 4)
输出: 7 -> 8 -> 0 -> 7
```

[题解：](https://github.com/DangoSky/algorithm/blob/master/LeetCode/445.%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%20II.js)

1. 先翻转两个链表，再逐个节点相加。维护一个 ans 和 pre 变量。ans 为当前的结果，pre 为上次的结果。因为高位是在链表头，所以每次都把 ans 的 next 指向 pre 即可。需要注意两个链表可能不等长，当前节点可能为空，为空直接使当前的节点值为0即可。以及可能循环完毕后还有一个进位，所以最后还需要再处理下进位的问题。


### 725. 分隔链表

```
给定一个头结点为 root 的链表, 编写一个函数以将链表分隔为 k 个连续的部分。每部分的长度应该尽可能的相等: 任意两部分的长度差距不能超过 1，也就是说可能有些部分为 null。

这k个部分应该按照在链表中出现的顺序进行输出，并且排在前面的部分的长度应该大于或等于后面的长度。

返回一个符合上述规则的链表的列表。举例： 1->2->3->4, k = 5 // 5 结果 [ [1], [2], [3], [4], null ]

示例 1：
输入: root = [1, 2, 3], k = 5
输出: [[1],[2],[3],[],[]]
解释:
输入输出各部分都应该是链表，而不是数组。
例如, 输入的结点 root 的 val= 1, root.next.val = 2, \root.next.next.val = 3, 且 root.next.next.next = null。
第一个输出 output[0] 是 output[0].val = 1, output[0].next = null。
最后一个元素 output[4] 为 null, 它代表了最后一个部分为空链表。

示例 2：
输入: root = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k = 3
输出: [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]]
解释:
输入被分成了几个连续的部分，并且每部分的长度相差不超过1.前面部分的长度大于等于后面部分的长度。
```

[题解：](https://github.com/DangoSky/algorithm/blob/master/LeetCode/725.%20%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8.js)

1. 先计算链表长度len，len / k 即每个子链表的最小长度，len % k 即剩下还有多少个节点。如果剩下的节点数大于0的话，则先给前面的子链表多增加一个节点，直至剩下的节点数为0。当子链表长度达到要求后就放入数组中，重新开始。需要注意的是最后得到的子链表数可能小于k，需要在数组中用 null 补充。


### 430. 扁平化多级双向链表

```
您将获得一个双向链表，除了下一个和前一个指针之外，它还有一个子指针，可能指向单独的双向链表。这些子列表可能有一个或多个自己的子项，依此类推，生成多级数据结构，如下面的示例所示。

扁平化列表，使所有结点出现在单级双链表中。您将获得列表第一级的头部。

示例:
输入:
 1---2---3---4---5---6--NULL
         |
         7---8---9---10--NULL
             |
             11--12--NULL

输出: 1-2-3-7-8-11-12-9-10-4-5-6-NULL
```

[题解：](https://github.com/DangoSky/algorithm/blob/master/LeetCode/430.%20%E6%89%81%E5%B9%B3%E5%8C%96%E5%A4%9A%E7%BA%A7%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.js)

1. 遍历链表，若当前节点有child则先把原链表的next保存到一个数组头部，并把当前节点的child置空，将当前节点的 next 指向 child。 等所有的child都添加到链表上后再从数组中取出之前保存的链表剩余部分继续拼接。需要注意的是，当拼接完最底层的链表后，此时当前节点的 next 为空，但数组中还有未拼接的链表，所以需要对这种情况做判断并处理。


### 817. 链表组件

```
给定一个链表（链表结点包含一个整型值）的头结点 head。同时给定列表 G，该列表是上述链表中整型值的一个子集。返回列表 G 中组件的个数，这里对组件的定义为：链表中一段最长连续结点的值（该值必须在列表 G 中）构成的集合。

示例 1：
输入: 
head: 0->1->2->3
G = [0, 1, 3]
输出: 2
解释: 
链表中,0 和 1 是相连接的，且 G 中不包含 2，所以 [0, 1] 是 G 的一个组件，同理 [3] 也是一个组件，故返回 2。

示例 2：
输入: 
head: 0->1->2->3->4
G = [0, 3, 1, 4]
输出: 2
解释: 
链表中，0 和 1 是相连接的，3 和 4 是相连接的，所以 [0, 1] 和 [3, 4] 是两个组件，故返回 2。
```

[题解：](https://github.com/DangoSky/algorithm/blob/master/LeetCode/817.%20%E9%93%BE%E8%A1%A8%E7%BB%84%E4%BB%B6.js)

1. 先使用 map/对象 标记链表中每一个节点在列表 G 中是否存在。遍历链表，维护两个变量，一个标记组件是否开始，一个标记当前节点是否存在列表中。组件开始后若当前节点不在列表中，则组件数加1。需要注意的是链表循环结束后可能组件还没结束，此时组件数需要再加1。


### 876. 链表的中间结点

```
给定一个带有头结点 head 的非空单链表，返回链表的中间结点。如果有两个中间结点，则返回第二个中间结点。

示例 1：
输入：[1,2,3,4,5]
输出：此列表中的结点 3 (序列化形式：[3,4,5])
返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。

注意，我们返回了一个 ListNode 类型的对象 ans，这样：
ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.
```

[题解：](https://github.com/DangoSky/algorithm/blob/master/LeetCode/876.%20%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E7%BB%93%E7%82%B9.js)

1. 快慢指针，慢指针移动的距离是快指针的一半。

2. 双向链表。

3. 通过链表长度来取中间结点。


### 1019. 链表中的下一个更大节点

```
给出一个以头节点 head 作为第一个节点的链表。链表中的节点分别编号为：node_1, node_2, node_3, ... 。每个节点都可能有下一个更大值（next larger value）：对于 node_i，如果其 next_larger(node_i) 是 node_j.val，那么就有 j > i 且  node_j.val > node_i.val，而 j 是可能的选项中最小的那个。如果不存在这样的 j，那么下一个更大值为 0 。

返回整数答案数组 answer，其中 answer[i] = next_larger(node_{i+1}) 。

注意：在下面的示例中，诸如 [2,1,5] 这样的输入（不是输出）是链表的序列化表示，其头节点的值为 2，第二个节点值为 1，第三个节点值为 5 。

示例 1：
输入：[2,1,5]
输出：[5,5,0]
```

[题解：](https://github.com/DangoSky/algorithm/blob/master/LeetCode/1019.%20%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E8%8A%82%E7%82%B9.js)

1. 类似于选择排序。先把链表中的节点值保存到一个数组中。


### 1171. 从链表中删去总和值为零的连续节点

```
给你一个链表的头节点 head，请你编写代码，反复删去链表中由 总和 值为 0 的连续节点组成的序列，直到不存在这样的序列为止。删除完毕后，请你返回最终结果链表的头节点。

你可以返回任何满足题目要求的答案。（注意，下面示例中的所有序列，都是对 ListNode 对象序列化的表示。）

示例 1：
输入：head = [1,2,-3,3,1]
输出：[3,1]
提示：答案 [1,2,1] 也是正确的。

示例 2：
输入：head = [1,2,3,-3,4]
输出：[1,2,4]

示例 3：
输入：head = [1,2,3,-3,-2]
输出：[1]
```

[题解：](https://github.com/DangoSky/algorithm/blob/master/LeetCode/1171.%20%E4%BB%8E%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%88%A0%E5%8E%BB%E6%80%BB%E5%92%8C%E5%80%BC%E4%B8%BA%E9%9B%B6%E7%9A%84%E8%BF%9E%E7%BB%AD%E8%8A%82%E7%82%B9.js)

1. 计算各个节点的前缀和。对于前缀和相同的项，说明这两个节点之间的和为0，可以消除他们中间的数（包括第二个节点的数）。用map来记录每个前缀和对应的链表节点。有重复的前缀和，就将上一个相同前缀和的节点的next指向当前相同前缀和的节点的next。需要注意的是：

- 拼接next前需要将记录他们中间的数的map清空，以免对之后的判断造成影响。
- 链表可能是 `0 -> null`，所以需要建一个虚拟节点（0），将其next指向head，这样可以先将0记录在map中。
- 链表可能是 `0 -> 0 -> null`，按上述步骤删除掉第一个0后，会清出map对0的记录，这时虚拟节点（0）的记录也被清空了，所以清空完成相应的map后，还需要把当前的前缀和记录为上一个节点。



## 树专题

[二叉树遍历](https://github.com/DangoSky/algorithm/tree/master/Algorithm-notes#%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91)


### 96. 不同的二叉搜索树

```
给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？

示例:
输入: 3
输出: 5
解释:
给定 n = 3, 一共有 5 种不同结构的二叉搜索树:

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
```

[题解：](https://github.com/DangoSky/algorithm/blob/master/LeetCode/96.%20%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.js)

1. 假设n个节点存在二叉排序树的个数是G(n)，令f(i)为以i为根的二叉搜索树的个数，则 `G(n) = f(1) + f(2) + f(3) + f(4) + ... + f(n)`。当i为根节点时，其左子树节点个数为i-1个，右子树节点为n-i，则`f(i) = G(i-1)*G(n-i)`。综合两个公式可以得到卡特兰数公式 `G(n) = G(0)*G(n-1)+G(1)*(n-2)+...+G(n-1)*G(0)`。


### 95. 不同的二叉搜索树 II

```
给定一个整数 n，生成所有由 1 ... n 为节点所组成的二叉搜索树。
示例:
输入: 3
输出:
[
  [1,null,3,2],
  [3,2,null,1],
  [3,1,null,null,2],
  [2,1,3],
  [1,null,2,null,3]
]
解释:
以上的输出对应以下 5 种不同结构的二叉搜索树：

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
```

[题解：](https://github.com/DangoSky/algorithm/blob/master/LeetCode/95.%20%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%20II.js)


1. 递归。编写一个生成 start...end 为根节点所组成的二叉搜索树的函数。循环分别以 start...end 为根节点，则其左右子树范围分别为 [start, i-1] 和 [i+1, end]，递归左右子树得到左右子树的所有可能。把左右子树数组两两搭配作为当前根节点的左右子树，存进数组中。最后即可得到所有由 1 ... n 为节点所组成的二叉搜索树。


### 98. 验证二叉搜索树

```
给定一个二叉树，判断其是否是一个有效的二叉搜索树。

假设一个二叉搜索树具有如下特征：
节点的左子树只包含小于当前节点的数。
节点的右子树只包含大于当前节点的数。
所有左子树和右子树自身必须也是二叉搜索树。
```

[题解：](https://github.com/DangoSky/algorithm/blob/master/LeetCode/98.%20%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.js)

1. 二叉搜索树的中序遍历的结果就是升序的，所以只要中序遍历一遍，比较当前节点和数组中它的前一个节点的大小即可。

### 100. 相同的树

```
给定两个二叉树，编写一个函数来检验它们是否相同。
如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。
```

[题解：](https://github.com/DangoSky/algorithm/blob/master/LeetCode/100.%20%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91.js)

1. 递归比较两棵树的左右子树。递归终止条件是两棵树都为null或其中一个为null或两棵树的节点值不相等。


### 101. 对称二叉树

```
给定一个二叉树，检查它是否是镜像对称的。
例如，二叉树 [1,2,2,3,4,4,3] 是对称的。

    1
   / \
  2   2
 / \ / \
3  4 4  3
```

[题解：](https://github.com/DangoSky/algorithm/blob/master/LeetCode/101.%20%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.js)

1. 递归。把一棵树抽象成两棵 l 和 r，对称的话则 l.left 和 r.right 、l.right, r.left 是相等的。递归代码大致同上题。


### 104. 二叉树的最大深度

```
给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

说明: 叶子节点是指没有子节点的节点。
```

[题解：](https://github.com/DangoSky/algorithm/blob/master/LeetCode/104.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6.js)

1. 递归左右子树，每次递归后比较左右子树的深度大小，在其基础上加1返回做回本层的深度。


### 105. 从前序与中序遍历序列构造二叉树

```
根据一棵树的前序遍历与中序遍历构造二叉树。

注意:
你可以假设树中没有重复的元素。

例如，给出
前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
```

[题解：](https://github.com/DangoSky/algorithm/blob/master/LeetCode/105.%20%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.js)

1. 先序遍历的第一个节点就是根节点，所以遍历中序遍历找出根节点的位置，通过根节点在中序遍历中的索引 index 即可得到左右子树各自所包含的节点数（左子树的节点是 index - inL）。则左右子树各自的前序中序遍历位置为 `(preL+1, preL+leftNum, inL, index-1)`， `(preL+leftNum+1, preR, index+1, inR)` 递归构建左右子树即可。

### 106. 从中序与后序遍历序列构造二叉树

```
根据一棵树的中序遍历与后序遍历构造二叉树。

注意:
你可以假设树中没有重复的元素。

例如，给出
中序遍历 inorder = [9,3,15,20,7]
后序遍历 postorder = [9,15,7,20,3]
```

[题解：](https://github.com/DangoSky/algorithm/blob/master/LeetCode/106.%20%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.js)

1. 思路同上，只是根节点换做了后序遍历的最后一个节点。找出根节点在中序遍历中的索引后，左右子树各自的中序后序遍历位置为 `(l1, index - 1, l2, l2 + sum - 1)`，`(index + 1, r1, l2 + sum, r2 - 1)`。


### 108. 将有序数组转换为二叉搜索树

```
将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。
```

[题解：](https://github.com/DangoSky/algorithm/blob/master/LeetCode/108.%20%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.js)

1. 数组的中间节点就是这个二叉搜索树的根节点，其数组索引是 `l + Math.floor((r - l) / 2)`，递归构建左右子树就可以了。


### 110. 平衡二叉树

```
给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。
```

[题解：](https://github.com/DangoSky/algorithm/blob/master/LeetCode/110.%20%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.js)

1. 先编写求树深度的函数，得到左右子树的深度。若左右子树平衡的话，则递归判断左右子树内部是否也平衡。


### 111. 二叉树的最小深度

```
给定一个二叉树，找出其最小深度。最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

说明: 叶子节点是指没有子节点的节点。
```

[题解：](https://github.com/DangoSky/algorithm/blob/master/LeetCode/111.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6.js)

1. 递归获取左右子树。如果左右子树的深度都不为0的话，则取最小值 + 1（加1是算上根节点）。若有一个或两个都为0的话，则取 ` 1 + left + right`。


### 112. 路径总和

```
给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。
说明: 叶子节点是指没有子节点的节点。

示例: 
给定如下二叉树，以及目标和 sum = 22，

              5
             / \
            4   8
           /   / \
          11  13  4
         /  \      \
        7    2      1
返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5->4->11->2。
```

[题解：](https://github.com/DangoSky/algorithm/blob/master/LeetCode/112.%20%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C.js)

1. 可以先假设一颗空树、只有根结点的树、只有一个根节点和一个叶子结点的树，假设出几颗树后根据这些情况编写递归式和终止条件。递归左右子树，每次递归左右子树时把 sum 减去当前根节点的值即可。

### 113. 路径总和 II

```
给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。

说明: 叶子节点是指没有子节点的节点。

示例:
给定如下二叉树，以及目标和 sum = 22，

              5
             / \
            4   8
           /   / \
          11  13  4
         /  \    / \
        7    2  5   1
返回:

[
   [5,4,11,2],
   [5,8,4,5]
]
```

[题解：](https://github.com/DangoSky/algorithm/blob/master/LeetCode/113.%20%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C%20II.js)

1. 编写一个用来递归的函数，接受三个参数分别是根节点root、目标和sum 和当前的路径数组。每次都把当前的节点存入路径数组中，再以当前路径递归其左右子树。如果当前节点左右子树为空且节点值等于目标和，则路径成立。此时需要把当前的路径数组拷贝一份后再放入结果数组中，否则会影响到后续操作，并且把的当前的节点值pop出路径数组，才好回溯寻找其他路径。


### 114. 二叉树展开为链表

```
给定一个二叉树，原地将它展开为链表。

例如，给定二叉树

    1
   / \
  2   5
 / \   \
3   4   6
将其展开为：

1
 \
  2
   \
    3
     \
      4
       \
        5
         \
          6
```

[题解：](https://github.com/DangoSky/algorithm/blob/master/LeetCode/114.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8.js)

1. 分为三个过程：1.左子树插入到右子树的地方。 2.将原来的右子树接到左子树的最右边节点。3.继续迭代右子树。


### 116. 填充每个节点的下一个右侧节点指针

```
给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：

struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。初始状态下，所有 next 指针都被设置为 NULL。
```

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/15/116_sample.png)

[题解：]()

1. 自顶向下递归。左孩子的next都是父节点的右孩子。若父节点的next存在，则右孩子的next是其父节点的next的左孩子，不存在的话则是null。以此递归左右子树。

2. 相当于层次遍历。用一个数组存储当前层次的所有节点，先使用一个变量sum标记当前层次的的节点数量。若遍历到当前节点时，sum不为0，则其next是数组中的第一个节点，否则为null。


### 117. 填充每个节点的下一个右侧节点指针 II

```
给定一个二叉树

struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。初始状态下，所有 next 指针都被设置为 NULL。
```

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/15/117_sample.png)

[题解：](https://github.com/DangoSky/algorithm/blob/master/LeetCode/117.%20%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88%20II.js)

1. 层序遍历存储遍历的顺序，使用 next 代替 queue进行层序遍历。

### 129. 求根到叶子节点数字之和

```
给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。
例如，从根到叶子节点路径 1->2->3 代表数字 123。
计算从根到叶子节点生成的所有数字之和。
说明: 叶子节点是指没有子节点的节点。

示例 1:
输入: [1,2,3]
    1
   / \
  2   3
输出: 25
解释:
从根到叶子节点路径 1->2 代表数字 12.
从根到叶子节点路径 1->3 代表数字 13.
因此，数字总和 = 12 + 13 = 25.
```

[题解：]()

1. 思路类同于寻找二叉树的所有路径，在递归左右子树前把当前路径的数字和 sum * 10 + root.val。并在叶子节点时将 sum 加入结果 res 后，sum需要减去当前节点的值以便回溯其他路径的数字和。

### 

```

```

[题解：]()


### 

```

```

[题解：]()


### 

```

```

[题解：]()


### 

```

```

[题解：]()