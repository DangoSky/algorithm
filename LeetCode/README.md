# 题解

- [链表专题](##链表专题)

## 链表专题

### 2.两数相加

```
给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。

如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。

您可以假设除了数字 0 之外，这两个数都不会以 0 开头。

示例：
输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)
输出：7 -> 0 -> 8
原因：342 + 465 = 807
```

[题解：](https://github.com/DangoSky/algorithm/blob/master/LeetCode/2.%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0.js)

1. 直接遍历链表，对两个节点的值进行相加。注意两个链表长度可能不一，需要判断当前的链表节点存在。


### 19.删除链表的倒数第N个节点

```
给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。

示例：

给定一个链表: 1->2->3->4->5, 和 n = 2.

当删除了倒数第二个节点后，链表变为 1->2->3->5.
```

[题解：](https://github.com/DangoSky/algorithm/blob/master/LeetCode/19.%20删除链表的倒数第N个节点.js)

1. 翻转一次链表，遍历到 n 的位置删除节点后再翻转回来。注意需要对第一个节点做特殊处理，如果删除的是第一个节点，则直接返回 `head.next` 就可以了。

2. 先遍历一次链表计算出链表长度，再遍历一次链表，根据 `curIndex + 1 === length - n` 的条件判断下一个节点是否是要删除的节点（curIndex从0开始）。同样需要对第一个节点做特殊处理。

3. 先后指针。快指针先走 n-1 步后慢指针再开始从头节点开始走。当快指针走到最后一个结点的时候，慢指针就走到了倒数第n个结点。使用一个 `pre = null` 来保存上一个节点，到达倒数第n个节点后使 `pre.next = slow.next` 再返回 head 即可。如果 `pre === null` 即要删除的是第一个节点，则直接返回 `slow.next`。

证明：

- 假设总共有N个结点，则倒数第n个结点就是正数第 N-n+1 个结点。
- 从头结点正向走到第 N-n+1 个结点需要走 N-n 步，而从头节点到链表最后一个结点需要走 N-1 步，所以还剩 n+1 步。
- 即让快指针先走 n+1 步后再让慢指针同时走直到快指针走到链表尾即可。


### 21.合并两个有序链表

```
将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

示例：
输入：1->2->4, 1->3->4
输出：1->1->2->3->4->4
```

[题解：](https://github.com/DangoSky/algorithm/blob/master/LeetCode/21.%20合并两个有序链表.js)

1. 建立一个新链表，遍历两个链表边比较节点值的大小边增加到新链表上。注意两个链表可能不等长，需要判断当前两个链表的节点是否存在。

2. 递归：可以看成是由多个相同的合并操作组合成的，每个合并过程都包括比较并取节点的值作为新节点的值，继续比较剩下的两个链表并放回其结果作为当前新节点的 next 指向。


### 23.合并K个排序链表

```
合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。

示例:
输入:
[
  1->4->5,
  1->3->4,
  2->6
]
输出: 1->1->2->3->4->4->5->6
```

[题解：](https://github.com/DangoSky/algorithm/blob/master/LeetCode/23.%20%E5%90%88%E5%B9%B6K%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8.js)

1. 同上题，只要加一个 for 循环 k，两两合并最后成一个链表即可。但貌似更优解是使用优先队列。


### 24.两两交换链表中的节点

```
给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。

你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

示例:
给定 1->2->3->4, 你应该返回 2->1->4->3.
```

[题解：](https://github.com/DangoSky/algorithm/blob/master/LeetCode/24.%20%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.js)

1. 递归：维护四个节点，取链表的第一个节点作为 first，第二个节点作为 second，第三个节点作为 three。只要使 `second.next = first`, 并递归操作 three，将其返回值赋值给`first.next`，每次递归都返回 second。


### 61.旋转链表

```
给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。

示例 1:
输入: 1->2->3->4->5->NULL, k = 2
输出: 4->5->1->2->3->NULL

解释:
向右旋转 1 步: 5->1->2->3->4->NULL
向右旋转 2 步: 4->5->1->2->3->NULL
```

[题解：](https://github.com/DangoSky/algorithm/blob/master/LeetCode/61.%20%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8.js)

1. 使用数组存储各个节点的值，再以此生成链表。注意为了避免 k 太大时循环太多次，使用 `k = k % arr.length` 优化，每次移动相当于将数组的末元素放到首位置上，`arr.unshift(arr.pop())`。

2. 相当于倒数第k个节点（正数第 len-k+1 个节点）变成了头节点，第 len-k 个节点变成了尾节点。所以移动到第len-k个节点，将其下一个节点缓存为新头节点，并将当前节点节点的 next 指向 null。再遍历到尾节点将其 next 修改为 head 即可。


### 82.删除排序链表中的重复元素 II

```
给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。

示例 1:
输入: 1->2->3->3->4->4->5
输出: 1->2->5
```

[题解：](https://github.com/DangoSky/algorithm/blob/master/LeetCode/82.%20%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%20II.js)

1. 使用两个变量 pre（初始化为null）和 end（初始化为 cur.next）记录重复节点的前一个节点和最后一个节点。循环链表，遇到有重复值的节点，就嵌套一次循环直至重复结束。如果 `pre === null`（首节点就重复了），则直接 `head = end.next`，否则 `pre.next = end.next`，以此截断调重复的节点。

2. 递归。若当前节点和下一个节点值不重复，则递归其 next 指针并将返回值作为当前节点的 next。若值重复了，则循环直至不重复，将不重复的节点进行递归并返回其返回值（作为上一次递归节点的 next）。


### 83.删除排序链表中的重复元素

``` 
给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。

示例 1:
输入: 1->1->2
输出: 1->2
```

[题解：](https://github.com/DangoSky/algorithm/blob/master/LeetCode/83.%20%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0.js)

1. 循环链表，遇到重复的就把当前节点的 next 修改为 next.next。

2. 递归。和上一题的区别在于，本题先递归求解当前节点的 next，这样就可以使得重复元素也出现一次。之后再判断当前节点和下一个节点是否值重复，重复的话则循环直至不重复再返回。

3. 使用一个数组记录每个节点值出现的次数（边循环边记录），判断当前节点的下一个节点值对应的数组值是否大于1，是则将 next 修改为 next.next。



### 86.分隔链表

```
给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。

你应当保留两个分区中每个节点的初始相对位置。

示例:
输入: head = 1->4->3->2->5->2, x = 3
输出: 1->2->2->4->3->5
```

[题解：](https://github.com/DangoSky/algorithm/blob/master/LeetCode/86.%20%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8.js)

1. 双指针，一个链表收集小于x的，一个链表收集大于等于x的，最后把后者连接到前者上。

2. 先把结点值缓存到两个数组，然后根据小的数组链接链表，再继续连接大的数组。


### 92.反转链表 II

```
反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。

说明:
1 ≤ m ≤ n ≤ 链表长度。

示例:
输入: 1->2->3->4->5->NULL, m = 2, n = 4
输出: 1->4->3->2->5->NULL
```

[题解：](https://github.com/DangoSky/algorithm/blob/master/LeetCode/92.%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%20II.js)

1. 将pre从m不断推移到n，把它连接到next后面并修改它的next指向，再将next连接到before后面。循环这个过程即可。例如 1->2->3->4->5->NULL,m=2,n=4。将pre(2)放到next(3)后面，就成了 3->2，改变pre(2)的next指向就成了3-2->4->5->NULL。再把next(3)链接到before(1)后面，1->3-2->4->5->NULL，以此类推。

- before为开始翻转的前一个结点
- pre为要开始翻转的结点
- next为pre的下一个结点

2. 遍历链表，使用数组暂存 m-n 节点的值（将节点值插入到数组头部）。再遍历一边，根据数组修改 m-n 的节点值。可以使用同一个函数进行两次遍历，再传一个参数表示是获取 or 修改节点值就可以。


### 109.有序链表转换二叉搜索树

```
给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。

本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。

示例:
给定的有序链表： [-10, -3, 0, 5, 9],

一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：

      0
     / \
   -3   9
   /   /
 -10  5
```

[题解：](https://github.com/DangoSky/algorithm/blob/master/LeetCode/109.%20%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.js)

1. 通过二叉搜索树的性质，可得链表的中间节点就是二叉树的根节点。使用快慢指针，慢指针每次移动一个节点，快指针每次移动两个节点，当快节点达到末尾时慢指针就到中间节点。对于一个偶数长度的链表，中间两个元素都可用来作二叉搜索树的根。找到中加节点后，把链表从中间断开成左右两部分（即树的左右子树），以此递归即可。需要使用一个变量来保存中间节点的前一个节点，将其 next 指向 null 就是左子树了。


### 138.复制带随机指针的链表

```
给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。要求返回这个链表的深拷贝。 

示例：
输入：
{"$id":"1","next":{"$id":"2","next":null,"random":{"$ref":"2"},"val":2},"random":{"$ref":"2"},"val":1}

解释：
节点 1 的值是 1，它的下一个指针和随机指针都指向节点 2 。
节点 2 的值是 2，它的下一个指针指向 null，随机指针指向它自己。
 
提示：
你必须返回给定头的拷贝作为对克隆列表的引用。
```

[题解：](https://github.com/DangoSky/algorithm/blob/master/LeetCode/138.%20%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8.js#L38)

1. 先循环一遍链表，使用 map 缓存链表的各个结点，以节点为键，以一个新节点为值。再循环一遍链表，根据当前节点的 next 从 map 中取出对应的新节点，重新给节点的 next 赋值。但这方法是 O(n)的空间复杂度，O(n)的时间复杂度。

2. 使用三次while循环。O(1)的空间复杂度，O(n)的时间复杂度。《剑指offer》第187页。
  - 第一次在原链表上增加复制的结点，如: 1->1`->2->2`->3->3`->4->4。
  - 第二次循环给复制的结点的random赋值，可以直接定位到原结点.random.next，即为要赋值结点的random。
  - 第三次循环截取出复制的链表，如 1`->2`->3`->4`，即为所求。


### 141.环形链表

```
给定一个链表，判断链表中是否有环。

为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。（示意图看原题）

示例 1：
输入：head = [3,2,0,-4], pos = 1
输出：true

解释：链表中有一个环，其尾部连接到第二个节点。
```

[题解：](https://github.com/DangoSky/algorithm/blob/master/LeetCode/141.%20%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8.js)

1. 快慢指针。慢指针每次走一个节点，快指针每次走两个节点。如果快指针和慢指针在中途相遇则说明有环。

2. 遍历链表，使用 map 存储每一个节点。如果当前节点在 map 中已经存在则有环，不存在的话则存进 map 中。

### 142.环形链表 II

```
给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。

为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。

说明：不允许修改给定的链表。

示例 1：
输入：head = [3,2,0,-4], pos = 1
输出：tail connects to node index 1

解释：链表中有一个环，其尾部连接到第二个节点。
```

[题解：](https://github.com/DangoSky/algorithm/blob/master/LeetCode/142.%20%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%20II.js)

1. 快慢指针。先使用快慢指针找出是否有环。有环的话，假设链表起点到入环起点的距离是 a，入环起点到快慢指针交点的距离是 b。因为快指针走过的距离一直都是慢指针的两倍，所以整个环的长度减去 b = a（即交点再到入环起点的距离是 a）。所以只要再让一个指针从链表起点和原先的慢指针同步走，两者相等时就是入环起点（因为两者走的距离都是 a）。

2. 先遍历一遍，使用 map 存储每个节点的值，如果当前节点已经在 map 中出现（即环的起点），则给该节点设一个标记值。之后在循环一次链表，找到该标记值返回当前节点即可。

### 143. 重排链表

```
给定一个单链表 L：L0→L1→…→Ln-1→Ln ，
将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…

你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

示例 1:
给定链表 1->2->3->4, 重新排列为 1->4->2->3.
```

[题解：](https://github.com/DangoSky/algorithm/blob/master/LeetCode/143.%20%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8.js)

1. 双向链表。先循环一遍链表，维护一个 pre 使链表成为双向链表（pre初始为 null，最终为链表的最后一个节点）。之后再循环链表，通过 pre 往回得到前一个节点，插在链表当中。需要注意的是循环的次数是链表长度的一半，且最后一次循环时需要把链表尾部指向null，把剩下的节点裁剪掉。

2. 使用数组缓存。先循环一遍链表存下每个节点。之后再根据数组将相应的节点插入链表中。

3. 先深拷贝一次链表（递归拷贝），再翻转该拷贝的链表。把翻转后的链表节点插入原链表即可。

### 147. 对链表进行插入排序

```
对链表进行插入排序。插入排序的动画演示如上。从第一个元素开始，该链表可以被认为已经部分排序（用黑色表示）。每次迭代时，从输入数据中移除一个元素（用红色表示），并原地将其插入到已排好序的链表中。

插入排序算法：
插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。
每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。
重复直到所有输入数据插入完为止。
 
示例 1：
输入: 4->2->1->3
输出: 1->2->3->4
```

[题解：](https://github.com/DangoSky/algorithm/blob/master/LeetCode/147.%20对链表进行插入排序.js)

1. 相当于选择排序。将当前节点和已好排序的链表中的每一个节点比较大小并插入。需注意的是刚开始遍历时已排好序的链表为空，以及若已排序链表的第一个节点值大于当前节点，这两种情况下是将当前节点插入到已排序链表的首部。


### 148. 排序链表

```
在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。

示例 1:
输入: 4->2->1->3
输出: 1->2->3->4
```

[题解：](https://github.com/DangoSky/algorithm/blob/master/LeetCode/148.%20%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8.js)

1. 同数组的选择排序。

2. 先使用数组存储链表中的节点值，对数组进行 sort 排序。再遍历链表给节点值重新赋值。

### 160. 相交链表

```
编写一个程序，找到两个单链表相交的起始节点。

输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出：Reference of the node with value = 8

输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。

注意：
如果两个链表没有交点，返回 null.
在返回结果后，两个链表仍须保持原有的结构。
可假定整个链表结构中没有循环。
程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。
```

[题解：](https://github.com/DangoSky/algorithm/blob/master/LeetCode/160.%20%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8.js)

1. 先获取两个链表的长度，让较长的链表先移动直至剩下的链表长度和另一个链表长度相等。再同时遍历两个链表，判断当前的节点是否相等，是的话则是交点。


### 203. 移除链表元素

```
删除链表中等于给定值 val 的所有节点。

示例:
输入: 1->2->6->3->4->5->6, val = 6
输出: 1->2->3->4->5
```

[题解：](https://github.com/DangoSky/algorithm/blob/master/LeetCode/203.%20%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0.js)

1. 直接遍历链表。但需要注意对头节点做特殊处理，对于头节点不是改变 cur.next, 而是直接修改 cur 和 head。

2. 递归。


### 206. 反转链表

```
反转一个单链表。

示例:
输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL
```

[题解：](https://github.com/DangoSky/algorithm/blob/master/LeetCode/206.%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.js)

1. 从第一个节点开始遍历，维护一个 pre 变量（初始化为 null）即可。

2. 递归。将下一个节点的 next 修改为 当前节点 head，head 的 next 修改为 null。

3. 使用数组缓存每个节点值，从数组尾部开始给每一个节点赋值。


### 234. 回文链表

```
请判断一个链表是否为回文链表。

示例 1:
输入: 1->2
输出: false

示例 2:
输入: 1->2->2->1
输出: true
```

[题解：](https://github.com/DangoSky/algorithm/blob/master/LeetCode/234.%20%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8.js)

1. 数组缓存每个节点。将数组转化为字符串，和翻转后的数组字符串化比较。

2. 双向链表。先给链表的每一个节点增加一个 pre 属性。同时从头到尾和从尾到头比较当前节点值是否相等。

3. 先深拷贝链表，再翻转链表，之后遍历两个链表，比较两者的当前节点值。


### 237. 删除链表中的节点

```
请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。

现有一个链表 -- head = [4,5,1,9]，它可以表示为:

示例 1:
输入: head = [4,5,1,9], node = 5
输出: [4,1,9]
解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.
```

[题解：](https://github.com/DangoSky/algorithm/blob/master/LeetCode/237.%20%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.js)

1. 直接修改待修改节点 的 val 和 next 就可以了。


### 328. 奇偶链表

```
给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。

请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。

示例 1:
输入: 1->2->3->4->5->NULL
输出: 1->3->5->2->4->NULL
```

[题解：](https://github.com/DangoSky/algorithm/blob/master/LeetCode/328.%20%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8.js)

1. 维护奇偶两条链表，遍历原先的链表将奇偶节点各自增加到相应的链表上，最后将偶链表拼接在奇链表上即可。

2. 先将链表的值存到数组中。再遍历链表修改当前节点的值。


### 445. 两数相加 II

```
给定两个非空链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储单个数字。将这两数相加会返回一个新的链表。你可以假设除了数字 0 之外，这两个数字都不会以零开头。

进阶:
如果输入链表不能修改该如何处理？换句话说，你不能对列表中的节点进行翻转。

示例:
输入: (7 -> 2 -> 4 -> 3) + (5 -> 6 -> 4)
输出: 7 -> 8 -> 0 -> 7
```

[题解：](https://github.com/DangoSky/algorithm/blob/master/LeetCode/445.%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%20II.js)

1. 先翻转两个链表，再逐个节点相加。维护一个 ans 和 pre 变量。ans 为当前的结果，pre 为上次的结果。因为高位是在链表头，所以每次都把 ans 的 next 指向 pre 即可。需要注意两个链表可能不等长，当前节点可能为空，为空直接使当前的节点值为0即可。以及可能循环完毕后还有一个进位，所以最后还需要再处理下进位的问题。


### 725. 分隔链表

```
给定一个头结点为 root 的链表, 编写一个函数以将链表分隔为 k 个连续的部分。每部分的长度应该尽可能的相等: 任意两部分的长度差距不能超过 1，也就是说可能有些部分为 null。

这k个部分应该按照在链表中出现的顺序进行输出，并且排在前面的部分的长度应该大于或等于后面的长度。

返回一个符合上述规则的链表的列表。举例： 1->2->3->4, k = 5 // 5 结果 [ [1], [2], [3], [4], null ]

示例 1：
输入: root = [1, 2, 3], k = 5
输出: [[1],[2],[3],[],[]]
解释:
输入输出各部分都应该是链表，而不是数组。
例如, 输入的结点 root 的 val= 1, root.next.val = 2, \root.next.next.val = 3, 且 root.next.next.next = null。
第一个输出 output[0] 是 output[0].val = 1, output[0].next = null。
最后一个元素 output[4] 为 null, 它代表了最后一个部分为空链表。

示例 2：
输入: root = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k = 3
输出: [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]]
解释:
输入被分成了几个连续的部分，并且每部分的长度相差不超过1.前面部分的长度大于等于后面部分的长度。
```

[题解：](https://github.com/DangoSky/algorithm/blob/master/LeetCode/725.%20%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8.js)

1. 先计算链表长度len，len / k 即每个子链表的最小长度，len % k 即剩下还有多少个节点。如果剩下的节点数大于0的话，则先给前面的子链表多增加一个节点，直至剩下的节点数为0。当子链表长度达到要求后就放入数组中，重新开始。需要注意的是最后得到的子链表数可能小于k，需要在数组中用 null 补充。


### 430. 扁平化多级双向链表

```
您将获得一个双向链表，除了下一个和前一个指针之外，它还有一个子指针，可能指向单独的双向链表。这些子列表可能有一个或多个自己的子项，依此类推，生成多级数据结构，如下面的示例所示。

扁平化列表，使所有结点出现在单级双链表中。您将获得列表第一级的头部。

示例:
输入:
 1---2---3---4---5---6--NULL
         |
         7---8---9---10--NULL
             |
             11--12--NULL

输出: 1-2-3-7-8-11-12-9-10-4-5-6-NULL
```

[题解：](https://github.com/DangoSky/algorithm/blob/master/LeetCode/430.%20%E6%89%81%E5%B9%B3%E5%8C%96%E5%A4%9A%E7%BA%A7%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.js)

1. 遍历链表，若当前节点有child则先把原链表的next保存到一个数组头部，并把当前节点的child置空，将当前节点的 next 指向 child。 等所有的child都添加到链表上后再从数组中取出之前保存的链表剩余部分继续拼接。需要注意的是，当拼接完最底层的链表后，此时当前节点的 next 为空，但数组中还有未拼接的链表，所以需要对这种情况做判断并处理。


### 

```

```

[题解：]()